# NOTES

## Basic rules to check stages of Cell Cycle

1. START of cell division (end of stationary G1) requires Cln3
2. G1 requires Cln3 to be deactivated and MBF, SBF to be activated
3. G1 to S requires activation of Clb5,6
4. G2 requires activation of Clb1,2
5. Entering M phase is indicated by activation of Cdc20, 14
6. Exit from M to G1 phase is indicated by deactivation of the same Cyclins

## Iteration 0: Reproduce `Table 2` of the paper `The yeast cell-cycle network is robustly designed`

1. Consider the directed graph of cyclin network given in Fig 1.B of the paper.
2. Design an algorithm based on the formula given in the paper to get $S_{i}(t+1)$ based on the value of $\sum_j a_j S_j(t)$
3. Try to reproduce `Table 2` for 15 iterations (no stop condition so far, hence need to use hardcoded iteration value)
4. Also use self-degradation loops for the cyclins where it is required.
5. Reproduce the table as closely as possible.

## Iteration 1: Generate scores for different starting state for a fully connected graph

1. Generate a fully connected graph (all nodes connected to all other nodes with green edges).
2. Generate all possible ($2^{11}$) starting states for the cyclins.
3. Pass every state through the same algorithm as `iteration 0` for 50 iterations.
4. Generate a score for each starting state and store the score.
5. Use `Manhattan Distance` for calculating the score, i.e for every cyclin, take absolute difference between every final state of the cyclin and the expected final state of the cyclin. Sum of all such differences is the final score for the starting state.

## Iteration 2: Generate scores for different graphs for all starting states. Random graphs are generated by adding or deleting two random edges of the given graph

1. Take the initial graph and calculate final score for it.
2. Score calculation of graph is sum of all start states for that graph.
3. Modify two edges for the graph randomly and calculate score for the graph.
4. Scores for the graph is stored as a dictionary with the perturbations as the key and the total score as the value.
5. Generate such graphs randomly with random module (create algo for it) and run it for several iterations.
6. Check if any of those iterations have less score compared to the original graph.

## Iteration 3: Generate Table 1 for all randomly modified graphs

1. Check the final state for all modified graphs.
2. Create a table with the mappings of how many starting states reach that final state.
3. Also create a separate .py file which can be used as a test. It can be used to pass custom parameters and to print the table when required.

## Iteration 4: Modify Score Parameter for G1 states

1. Modify scoring parameters according to paths taken
2. G1 starting, S phase, G2 phase, M phase
3. How to recognize if states are in correct order
4. First Cln1,2 activate, then Clb5,6, then Clb1,2, then Cdc2014 -> if not in this order, penalty score +1000. (Not at the same time)
5. Read the paper based on human cyclins

If graph final score is less than 751, run simulation for g1 start states checking for sequence. If seq not maintained, abort that state and log the states and graphs.

## G1: Start with this state should result in getting all other states in order

0: Swi5, Cdc2014, Clb56, Clb12, Mcm1
All others can be 0 or 1

## Iteration 5: Check state orders for original graph and compare it with modified graphs

1. Compute graph score for original graph, also get score for g1 states and punish 100 scores for all state tables that don't follow order.
2. Record both scores.
3. Get both scores for modified graphs and check if both scores are less for any of the modified graphs.

## Iteration 6: Replicate the very low score with the modified graph and create input file for mammal cell cycle

1. For mammalian cell cycle, if no green arrow coming to it, there should be self-activation arrow, i.e. if it stays zero for one cell cycle, flip it to one.
2. Change to replicate: CyclinD, p21-27, Cdh1 -> 1, others -> 0

## Iteration 7: More experiment with Yeast Cell Cycle

1. Represent the graph as matrix form to use in matlab
2. Share the mammal log file
3. Experiment with yeast cell cycle
4. Document

## Iteration 8: All possible perturbations and check scores for all graphs

1. Check all perturbations for Yeast Cell Graph and pass them to the cell cycle model
2. Check if we can use matrix form for perturbation (numpy)
3. Send mammal cell cycle in matrix form
4. Another paper to study

## Iteration 9: Matrix implementation and Pytest

1. Implement the same algorithms and logics using matrix representation for the graph
2. If possible, implement unit testing module using pytest

## Iteration 10: Histogram and Log Modification

1. Y-axis - Frequency of score differences (not absolute), X-axis differences (-ve values included)
2. Also for total score (graph_score + g1_graph_score)
3. Make it such that not everything is logged all the time. Put flags. Just scores are required for all perturbations.

## Iteration 11: Logs & Multiprocessing

1. Dump scores and Perturbations in an excel
2. Logs for all perturbations
3. Work on Multiprocessing
4. Also increase bincount for the histogram

## Iteration 12: Mammal Cell Cycle & Finalize Yeast Perturbation Frequency Graph

1. Freq Distn for Yeast Perurbations
2. Multiprocessing for mammal

## Iteration 13: Mammal Cell Cycle (Async Update, Cycle Detection, Multiprocessing)

1. Asynchronous update of cell states for mammal
2. Cycle detection and counting for cell states
3. Look up ARC Registration
4. Read Mammal Paper for Async Update scheme rules

## Iteration 14: Async Update

Options for Async Update:

- Option 1: Async update all nodes one by one in random order every pass. Result might vary from one execution to another, but it is guaranteed to affect all nodes for every pass.
- Option 2: Async update all nodes one by one in a specific pre-determined order.
- Option 3: Async update any randomly chosen node every time. This approach might not affect all the nodes equally every time and the result can be different for every execution.

Option 1 is selected after discussion.

## Iteration 15: Debugging

1. Very low score of budding yeast while running async -> list passed as reference in Python. Causing the issue that starting state was being modified multiple times.
2. Random order producing same score for all iterations
3. Third mammalian model
4. Read up method part of papers to document

## Iteration 16: Debug Async & Method Writing

1. Debug Async Update
2. Random order with replacement
3. Method writing from yeast paper - logic of self loops and logic of score update and logic of state updates

## Iteration 17: Faure Model and multiple iterations statistics for random async update

1. Create inputs for Faure model
2. Iterate 100s of times for random async update and average count for every state
3. Also note all the different possible final states
4. Could create a excel spreadsheet with all these info

## Iteration 18: Faure Model more experiment, Tyson paper, Self Loops

1. Hardcode self loops
2. Modify logic of cycle
3. Improve state print by printing what is getting updated
4. Try to do: Print only states that change
5. Bug while hardcoding self-loops: own state is also getting considered
6. Filter states

## Iteration 19: Manual & automated Perturbation to Faure model

1. Create a simplified GB model with skp2, cdc25, wee1 removed.
2. Try to make faure model as close to gb as possible and check if there is any diff bw the table 1s
3. 1 perturbation via code
4. Track number of final states and the state with max count for each perturbation
5. Remove ubch from faure model

## Iteration 20

1. If CyclinD goes to 0 before E2F1 goes to 1, then it is not incorrect order, rather cell cycle did not progress.
2. For each starting state, note how many times goes through correct order, incorrect order, does not start out of maybe 100 executions.

## Iteration 21

1. Async update for yeast cell cycle model.
2. Final state count table and 5000 iteration avg table should be presented.
3. Finally have 4 models: Yeast, GB, Tyson1, Tyson2 (with P21 self loop) - find metrics for all models.
