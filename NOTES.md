# NOTES

## Basic rules to check stages of Cell Cycle

1. START of cell division (end of stationary G1) requires Cln3
2. G1 requires Cln3 to be deactivated and MBF, SBF to be activated
3. G1 to S requires activation of Clb5,6
4. G2 requires activation of Clb1,2
5. Entering M phase is indicated by activation of Cdc20, 14
6. Exit from M to G1 phase is indicated by deactivation of the same Cyclins

## Iteration 0: Reproduce `Table 2` of the paper `The yeast cell-cycle network is robustly designed`

1. Consider the directed graph of cyclin network given in Fig 1.B of the paper.
2. Design an algorithm based on the formula given in the paper to get $S_{i}(t+1)$ based on the value of $\sum_j a_j S_j(t)$
3. Try to reproduce `Table 2` for 15 iterations (no stop condition so far, hence need to use hardcoded iteration value)
4. Also use self-degradation loops for the cyclins where it is required.
5. Reproduce the table as closely as possible.

## Iteration 1: Generate scores for different starting state for a fully connected graph

1. Generate a fully connected graph (all nodes connected to all other nodes with green edges).
2. Generate all possible ($2^{11}$) starting states for the cyclins.
3. Pass every state through the same algorithm as `iteration 0` for 50 iterations.
4. Generate a score for each starting state and store the score.
5. Use `Manhattan Distance` for calculating the score, i.e for every cyclin, take absolute difference between every final state of the cyclin and the expected final state of the cyclin. Sum of all such differences is the final score for the starting state.

## Iteration 2: Generate scores for different graphs for all starting states. Random graphs are generated by adding or deleting two random edges of the given graph.

1. Take the initial graph and calculate final score for it.
2. Score calculation of graph is sum of all start states for that graph.
3. Modify two edges for the graph randomly and calculate score for the graph.
4. Scores for the graph is stored as a dictionary with the perturbations as the key and the total score as the value.
5. Generate such graphs randomly with random module (create algo for it) and run it for several iterations.
6. Check if any of those iterations have less score compared to the original graph.
